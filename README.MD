# Calculadora de Fatorial em Java

Este projeto Java calcula o **fatorial de um n√∫mero inteiro n√£o-negativo**, utilizando diferentes abordagens, incluindo **recurs√£o**, **iterativo** e **programa√ß√£o din√¢mica** com `BigInteger`, para suportar valores grandes.

## üß† √â poss√≠vel calcular o fatorial de um n√∫mero acima de 100 com recurs√£o?

**Tecnicamente, sim.** Mas **n√£o √© recomendado**. Veja os motivos abaixo:

### ‚ùå Problemas da recurs√£o para n√∫meros grandes

* A recurs√£o em Java utiliza a **pilha de execu√ß√£o (stack)** da JVM.
* Cada chamada recursiva adiciona um novo frame √† pilha.
* A JVM possui um **limite de profundidade da pilha por thread**.
* Para n√∫meros muito grandes (ex: `fatorial(10000)`), o programa pode lan√ßar um:

  ```
  java.lang.StackOverflowError
  ```

### ‚úÖ Por que usamos `BigInteger`?

* O fatorial cresce exponencialmente. Exemplo: `100!` tem **158 d√≠gitos**!
* Tipos primitivos como `int` e `long` **estouram rapidamente**:

    * `20! = 2.432.902.008.176.640.000` ‚Üí j√° ultrapassa o limite do tipo `long`.
* `BigInteger` √© uma classe do Java que permite trabalhar com **n√∫meros inteiros muito grandes**, sem limite de tamanho.

---

## ‚úÖ C√≥digos para c√°lculo de fatorial

### ‚úÖ Solu√ß√£o Recursiva

```java
public static BigInteger fatorial(int n) {
    if (n == 0 || n == 1)
        return BigInteger.ONE;
    return BigInteger.valueOf(n).multiply(fatorial(n - 1));
}
```

> ‚ö†Ô∏è Funciona bem at√© \~1000, dependendo da configura√ß√£o da JVM.

---

### ‚úÖ Solu√ß√£o Iterativa

```java
public static BigInteger fatorialIterativo(int n) {
    BigInteger resultado = BigInteger.ONE;
    for (int i = 2; i <= n; i++) {
        resultado = resultado.multiply(BigInteger.valueOf(i));
    }
    return resultado;
}
```

> ‚úîÔ∏è Evita estouro de pilha e √© mais segura para grandes entradas.

---

### ‚úÖ Solu√ß√£o com Programa√ß√£o Din√¢mica

#### üîÅ Bottom-Up

```java
public static BigInteger fatorialBottomUp(int n) {
    BigInteger[] dp = new BigInteger[n + 1];
    dp[0] = BigInteger.ONE;
    for (int i = 1; i <= n; i++) {
        dp[i] = dp[i - 1].multiply(BigInteger.valueOf(i));
    }
    return dp[n];
}
```

#### üîÅ Top-Down (com memoiza√ß√£o)

```java
import java.util.HashMap;

public static BigInteger fatorialTopDown(int n, HashMap<Integer, BigInteger> memo) {
    if (n == 0 || n == 1)
        return BigInteger.ONE;
    if (memo.containsKey(n))
        return memo.get(n);
    BigInteger resultado = BigInteger.valueOf(n).multiply(fatorialTopDown(n - 1, memo));
    memo.put(n, resultado);
    return resultado;
}
```

---

## üîç Diferen√ßa entre a solu√ß√£o 2 (Iterativa) e a solu√ß√£o 3 (Programa√ß√£o Din√¢mica)

| Crit√©rio                | Iterativa                    | Programa√ß√£o Din√¢mica         |
| ----------------------- | ---------------------------- | ---------------------------- |
| Abordagem               | Loop simples                 | Memoiza√ß√£o ou tabela         |
| Uso de mem√≥ria          | Constante                    | Usa array ou estrutura extra |
| Performance             | Muito eficiente              | Similar, mas mais escal√°vel  |
| Reutiliza√ß√£o de valores | N√£o reutiliza explicitamente | Reutiliza via cache (DP)     |

* Ambas evitam estouro de pilha.
* A programa√ß√£o din√¢mica √© √∫til se precisar reutilizar fatorial de `n` v√°rias vezes.
* A abordagem bottom-up se comporta como a iterativa, mas guarda todos os resultados intermedi√°rios.

---

## üìå Resumo

* ‚úÖ A recurs√£o funciona para valores pequenos e m√©dios (at√© \~100‚Äì1000).
* ‚ö†Ô∏è Para valores maiores, use a **vers√£o iterativa** ou **din√¢mica**.
* ‚úÖ Sempre use `BigInteger` para garantir que o resultado n√£o ultrapasse os limites de tipos primitivos.
* ‚úÖ Programa√ß√£o din√¢mica permite **reutiliza√ß√£o de resultados parciais**, sendo ideal para sistemas mais complexos.

---

## üí° Como Executar

1. Compile o c√≥digo:

```bash
javac Fatorial.java
```

2. Execute:

```bash
java Fatorial
```

3. Insira um n√∫mero inteiro e veja o fatorial calculado.

---

## üõ† Requisitos

* Java 8 ou superior (recomendado Java 17+)

---


